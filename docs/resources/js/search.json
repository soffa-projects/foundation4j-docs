[[{"l":"Introduction","p":["Le projet Foundation est né de la volonté de fournir aux équipes de développement Java un outil permettant de construire simplement des solutions SaaS principalement mais par extension des microservices.","Notre objectif est d'embarquer dans cet outil les bonnes pratiques qu'il est difficile d'attendre de profils juniors dès leur intégration en entreprise. En effet, plusieurs entreprises recrutent un nombre important de jeunes diplômés et juniors. Même avec un encadrement de profils seniors, il est impossible d'attendre à ces profils de un certain niveau de qualité à court voire moyen terme.","Le dilemme c'est qu'en face, les clients attendent un produit de la plus haute qualité possible.","Notre réponse à ce situation est de fournir les briques nécessaires pour construire du logiciel de qualité, simple de prise en main par des juniors et ouvert en code source pour permettre aux développeurs de comprendre étape par étape le fonctionnement de la boîte magique.","Même des développeurs expérimentés apprécieront l'approche proposée."]},{"l":"Engagement","p":["Il est important pour nous d'exposer de façon explicite notre vision produit. Notre engagement, vis à vis de Foundation est donc le suivant:","Le code source de tout le framework est et sera toujours gratuit, hébergé sur Github, dans le domaine public","Toutes les librairies Java seront toujours publiées sur MavenCentral ( https://search.maven.org/)"]},{"l":"Projet Bantu","p":["Le terme doogfooding ou Eating your own dog food remonte à un mail interne chez Microsoft en 1988. Il s'agit d'une pratique qui consiste à utiliser ses propres produits afin de se confronter directement à ses qualités et défauts.","Pour garantir la qualité et l'expérience développeurs derrière Foundation, nous sommes aux premières lignes en utilisant toutes les briques Foundation dans un projet ambitieux Bantu.","Ce projet fournira à moyen terme des métriques très concrètes sur ce qu'il est possible de faire avec ce socle technique."]}],[{"l":"Choix structurants","p":["Pour construire Foundation, il fallait faire des choix structurants pour que chaque entreprise puisse décider très rapidement s'il y a un alignement avec sa stratégie interne.","Nous avons donc simplifié les choses et construit sur 4 choix structurants :"]},{"l":"Architecture hexagonale","p":["Ce premier choix était le plus simple à faire car nous considérons que l'architecture hexagonale est un solide pilier sur lequel une entreprise peut construire une stratégie logicielle long-terme.","L'objectif de cette architecture est de séparer, autant que faire se peut, le technique du fonctionnel en réduisant au maximum la dépendance vis à vis d'un framework technique.","Pour cette raison, nous classons Foundation dans la catégorie framework fonctionnel plutôt que technique car la priorité, comme on pourra le voir dans les sections suivantes, est donnée au domaine métier."]},{"l":"SpringBoot","p":["Nous faisons le choix de construire par dessus SpringBoot car c'est cetainement le framework Java le plus populaire en entreprise. Toutefois, l'objectif de Foundation est de masquer au mieux le technique. Même si c'est quelque chose que SpringBoot fait déjà très bien, nous souhaitons aller plus loin et offir une solution orientée \"fonctionnel\"."]},{"l":"Java 8","p":["Java8 est encore très populaire en entreprise et avoir un code compatible avec cette version est un important facteur pour l'adoption de l'outil."]},{"l":"Gradle","p":["Le 4e et dernier choix structurant, c'est Gradle, outil de build et gestion des dépendances retenu pour sa flexibilité principalement."]}],[{"l":"Bien démarrer","p":["Nous recommandons l'utilisation de Foundation si vous souhaitez construire un projet entreprise long terme (de taille moyenne ou grande) avec une importante dans la maintenabilité et la qualité.","Pour démarrer un projet avec Foundation4j, nous recommandons de télécharger le repository foundation-java-starter, puis suivre les 2 étapes suivantes:","Changer le nom du projet","Personnaliser le package, par défault à foundation.app","Voilà, vous pouvez commencer à travailler !"]},{"i":"anatomie-dun-projet","l":"Anatomie d'un projet","p":["Par défault, un projet créé avec le client foundation utilisera le template projet que nous recommandons. Ce template est un projet Gradle avec deux modules : api et service.","Anatomie d'un projet Foundation"]},{"l":"Module API","p":["Contient la description, avec un vocabulatire fonctionnel, de ce que l'application doit implémenter come usecases et ressources.","Dans les packages qui sont proposés, vous retrouvez:"]},{"i":"package-apischema","l":"Package api.schema","p":["Ce package contient le modèle de données (POJO) manipulés et produits par les usecases."]},{"i":"package-apiusecase","l":"Package api.usecase","p":["Ce package contient les interfaces décrivant les fonctionnalités du projet. Chaque usecase utilise un verbe en anglais pour clairement décrire la responsabilité.","En terme de bonnes pratiques, nous recommandons ce qui suit:","Un verbe commençant par Get indique qu'il s'agit d'une opération de lecture (Query)","Un verbe commençant par On indique qu'il s'git d'un événement (Event)","Tous les autres usecases sont considérés comme des opérations d'écriture (Command)","La définition d'un UseCase est une simple interface qui étend dev.soffa.foundation.core.UseCase. En ouvrant l'interface, on peut donc avoir une idée générale de que cette opération est censée faire, quel est l'input et quel est l'output.","Il est donc recommandé de toujours choisir une terminologie fonctionnelle simple à comprendre : Ubiquitous Language."]},{"i":"package-apiresources","l":"Package api.resources","p":["Ce package contient les interfaces des ressources que le projet expose (en REST, GraphQL, etc). Une ressource est une interface qui expose plusieurs opérations. Foundation inclut plusieurs dépendances par défaut, dont OpenAPI pour la documentation des APIs.","La méthode invoke déclarée dans l'inteface Resource permet au développeur de faire le mapping entre l'opération et le bone usecase.","Même si vous constatez des annotations SpringBoot à ce niveau, il ne s'agit que d'annotations. Les fichier correspodants ont été copier depuis le projet officiel Spring et coller dans foundation-api pour ne pas avoir à inclure toute la dépendance Spring dans ce module API. L'interprétation de ces interfaces n'est faite que dans la partie app-service."]},{"l":"Importance du module API","p":["Le module API permet de décrire le fonctionnement de votre service mais aussi de servir d'interface pour les clients. En effet, le module api pouvant être publié séparement dans un serveur nexus, peut être rajouté comme dépendance dans un autre service dans lequel le code suivant peut etre utilisé :","Il n'y a donc aucune génération de client à prévoir lorsque votre ressource doit être consommer depuis un code Java/Kotlin."]},{"l":"Module Core","p":["Contient l'implémentation des usecases(qui contiennent les règles de gestion). Cette implémentation peut nécessister l'accès à des ressources externes au système. L'interface de cette ressource externe est alors créée dans ce module et l'implémentation déléguée à la couche service"]},{"l":"Module Service","p":["Le module app-service contient l'implémentation de vos différents usecases à travers des handlers et autres classes support.","Foundation est construit sur SpringBoot. Toutefois, grâce à la fonctionnalit\" implementation de gradle, le développeur n'a pas accès aux différentes classes Spring. Ceci est fait par design pour encourager l'utilisateur de classes simplement définies ainsi que de classe telel que javax.inject.Named au lieu de @Component, @Service(...) de Spring."]},{"l":"Plugin gradle","p":["Active la publication vers un repository maven","Active le module Lombok sur le module","Active le plugin pmd sur le module","Applique le plugin checkstyle au module. Votre fichier checkstyle.xml doit être présent dans le dossier config/qa/","Applique le plugin foundation.api au module api de votre projet; Applique le plugin foundation.service au module service; Rajoute à votre module service la dépendance avec le service api","Applique le plugin foundation.api.kotlin au module api de votre projet; Applique le plugin foundation.service.kotlin au module service; Rajoute à votre module service la dépendance avec le service api","Applique les plugins foundation.java8 et foundation.test.junit5+ la dépendance dev.soffa.foundation:foundation-api","Applique les plugins foundation.kotlin et foundation.test.junit5+ la dépendance dev.soffa.foundation:foundation-api","Appliquer les plugins foundation.java8, foundation.springboot Rajouter les dépendances dev.soffa.foundation:foundation-starter et dev.soffa.foundation:foundation-starter-test","Appliquer les plugins foundation.kotlin, foundation.springboot Rajouter les dépendances dev.soffa.foundation:foundation-starter et dev.soffa.foundation:foundation-starter-test","Chaque projet Foundation inclut la dépendance au plugin gradle. Ce plugin permet de simplifier certaines configuration projet.","Configure la couverture de test à 100%","Configure la couverture de test à un min de 10%","Configure la couverture de test à un min de 20%","Configure la couverture de test à un min de 30%","Configure la couverture de test à un min de 40%","Configure la couverture de test à un min de 50%","Configure la couverture de test à un min de 60%","Configure la couverture de test à un min de 70%","Configure la couverture de test à un min de 80%","Configure la couverture de test à un min de 85%","Configure la couverture de test à un min de 90%","Configure la couverture de test à un min de 95%","Configure le module pour un développement avec Java11 + PMD","Configure le module pour un développement avec Java17 + PMD","Configure le module pour un développement avec Java8 + PMD","Configure le module pour un développement avec Kotlin et Java8+PMD","Configure les repositories par défaut pour tous les sous-modules: mavenLocal et mavenCentral","Configure les tests avec Junit5 pour le module","Configure les tests avec Karate pour le module","Description","foundation.api","foundation.api.kotlin","foundation.default-repositories","foundation.java11","foundation.java17","foundation.java8","foundation.kotlin","foundation.lombok","foundation.maven-publish","foundation.project","foundation.project.kotlin","foundation.qa.checkstyle","foundation.qa.coverage.l1","foundation.qa.coverage.l2","foundation.qa.coverage.l3","foundation.qa.coverage.l4","foundation.qa.coverage.l5","foundation.qa.coverage.l6","foundation.qa.coverage.l7","foundation.qa.coverage.l8","foundation.qa.coverage.l85","foundation.qa.coverage.l9","foundation.qa.coverage.l95","foundation.qa.coverage.lX","foundation.qa.pmd","foundation.service","foundation.service.kotlin","foundation.test.junit5","foundation.test.karate","Liste des plugins","module","Niveau","Plugin","root"]},{"i":"fichier-gradleproperties","l":"Fichier gradle.properties","p":["Le contenu par défaut de ce fichier de configuration devrait vous permettre de créer un service si vous n'avez pas besoin d'accéder à une base de données, un message broker, etc.","Si votre service a besoin de ces capacités, la ligne foundation.modules doit alors être décommentée avec les bonnes valeurs.","Modules foundation disponible","Module","Description","data","Module de gestion persistence (multi-tenant)","pubsub","Module de connexion à des bus de messages: Nats, Kafka, RabbitMQ)","storage","Module de connexion à un service Object Storage","tracing","Module d'intégration à un service de tracing (ex: Zipkin)"]},{"i":"plus-dexemples","l":"Plus d'exemples","p":["Le projet foundation-java-starter vous permet de disposer d'une structure basique pour démarrer rapidement. Nous vous invitons à consulter foundation4j-samples pour avoir plus d'exemples sur des cas d'usages plus avancés d'un simple Echo."]}],[{"l":"Structure applicative"},{"l":"Inbound Gateways","p":["Dans la terminologie de l'architecture hexagonale, un Inbound Gateway représente un point d'entrée de l'application: moyen par lequel les fonctionnalités peuvent être consommées par un client."]},{"i":"exposition-http-rest","l":"Exposition HTTP (Rest)","p":["Par défault toutes vos ressources sont exposées en Rest. C'est une valeur sûre de toujours commencer par ce type d'exposition. Les différents annotations importées depuis SpringBoot @RestController, RequestMapping(...) permettent la création de ressources REST. Il n'y rien de particulier rajouté par Foundation sur cette partie."]},{"i":"exposition-http-graphql","l":"Exposition HTTP (GraphQL)","p":["Le support GraphQL est toujours en construction, et prévue pour une release ultérieure. Pour cette implémentation nous avons retenu Netflix DGS. Cette section sera mise à jour une fois cette action finalisée."]},{"l":"PubSub","p":["Lorsque le module pubsub est activé, tous les usecases que vous déclarez sont automatiquement consommables (via RabbitMQ, Kafka ou Nats en fonction de votre choix). Le binding par défaut se base sur le nom de l'interface de votre usecase. Toutefois, l'annotation @Handle permet de personnaliser le nom de l'événement à traiter."]},{"l":"Scheduler","p":["Dans la version actuelle, Foundation conserve l'annotation @Scheduled de SpringBoot","Toutefois, l'API devrait évoluer pour offrir d'autres mécanismes"]},{"i":"usecaseoperation","l":"Usecase/Operation","p":["Déclarer un usecase (ou opération) commence par la définition de l'interface correspondante dans votre package -api. L'interface dev.soffa.foundation.core.UseCaseInput, Output est générique et requiert la définition des classes Input ou Output du UseCase. Lorsque votre Usecase n'accepte pas d'input, vous pouvez utiliser la classe Void.","L'implémentation du UseCase(dans le module -service) surcharge la méthode handle avec les classes Input et Output définies dans la signature et un paramètre suppélementaire de type Context. Ce second paramètre vous permet d'accéder à plusieurs informations relatives au contexte de la requête en cours."]},{"l":"Outbound Gateways","p":["Lorsque l'implémentation de votre UseCase a besoin d'accéder à des composants externes (base de données, communication avec un service externe, etc), il est important de toujours passer par une interface pour respecter le pattern Port/Adapter.","Pour accéder à une base de données par exemple, le UseCase devrait ressembler à ceci:","L'interface TodoRespoitory est définie comme suit :","Le développeur peut ensuite définir l'implémentation correspondante dans le package gateways.outbound car il s'agit d'une communication storate de l'application vers un composant externe."]},{"l":"Nomenclature","p":["gateways.inbound peut etre aussi nommée exposition","gateways.outbound peut etre aussi nommée infrastructure","Même si le nom peut changer, d'un style à l'autre, la sémantique reste la même: indentifier clairement :","les points d'entrées (comment vos ressources et usecases sont consommées)","Les points de sorties (ce que votre application consomme pour fonctionner correctement)"]}],[{"l":"OpenAPI"},{"l":"Redoc","p":["En supposant que votre projet soit configué sur le port 8080, lorsque vous démarrez l'application, la age d'accueil vous afficher la présentation de votre API avec Redoc","http://localhost:8080"]},{"l":"Configuration"},{"l":"OpenAPI","p":["http://localhost:8080/swagger-ui/index.html"]},{"i":"configuration-1","l":"Configuration","p":["Pour personnaliser les informations de votre API, nous recommandons de créer un fichier openapi.yml et de l'importer dans votre fichier application.yml comme suit:"]}],[{"l":"Observabilité","p":["Chaque application Foundation embarque un certain nombre de capacités activées par défaut. Dans la catégorie Observabilité on retrouve les éléments suivants :"]},{"l":"Health check","p":["Pour avoir un état du service, l'uri /health est disponible en alias de /actuator/health(configuration par défaut SpringBoot)"]},{"l":"Métriques applicatives","p":["Votre application embarque par défault une exposition pour Prometheus disponible sur /metrics en alias de /actuator/prometheus(configuration par défaut SpringBoot)"]},{"l":"Logs","p":["Foundation embarque slf4j pour la gestion des logs. Toutefois, au lieu d'utiliser directement le classe org.slf4j.LoggerFactory pour créer votre logger, remplacer par dev.soffa.foundation.commons.Logger vous permet de bénéficier de quelques avantages dont l'injection du contexte de la requête dans vos logs. Chaque log produit contiendra donc:","Le nom de l'application appelante","Le tenant actif (si votre service est multitenant)","Les informations de trace traceId et spanId","L'identifiant de l'utilisateur connecté (si applicable)"]},{"l":"Exceptions","p":["Les stacktraces en Java sont très verbeux et il est souvent difficile d'identifier rapidement la bonne information. Foundation intègre la librair MgntUtils pour supprimer des stacktraces les lignes qui ne sont pas pertinents.","Au démarrage de votre application, le package principal est détecté et utilisé pour filter les traces d'erreurs."]},{"i":"traces-distribuées-distributed-tracing","l":"Traces distribuées (Distributed tracing)"},{"l":"Audit logging"}],[{"l":"Métriques","p":["#TODO"]}],[{"l":"Persistence"}],[{"l":"Multitenancy"}],[{"l":"Introduction"}],[{"l":"Mail"}],[{"l":"Object storage"}],[{"l":"Pubsub"}],[{"l":"Tracing"}],[{"l":"Introduction"}]]